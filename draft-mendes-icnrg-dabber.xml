<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?><?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="exp" docName="draft-mendes-icnrg-dabber-04" ipr="trust200902">


<front>
<title abbrev="draft-mendes-icnrg-dabber-04">Information-centric Routing for Opportunistic Wireless Networks</title>
<author fullname="Paulo Mendes" initials="P." role="editor"
            surname="Mendes">
      <organization>Airbus</organization>
      <address>
        <postal>
          <street>Willy-Messerschmitt Strasse 1</street>
          <city>Munich</city>
          <code>81663</code>
          <country>Germany</country>
        </postal>
        <email>paulo.mendes@airbus.com</email>
        <uri>http://www.paulomilheiromendes.com</uri>
      </address>
</author>
<author fullname="Rute C. Sofia" initials="R."
            surname="Sofia">
      <organization>fortiss GmbH</organization>
      <address>
        <postal>
          <street>Guerickestrasse 25</street>
          <city>Munich</city>
          <code>80805</code>
          <country>Germany</country>
        </postal>
        <email>sofia@fortiss.org</email>
        <uri>http://www.rutesofia.com</uri>
      </address>
</author>
<author fullname="Vassilis Tsaoussidis" initials="V."
            surname="Tsaoussidis">
      <organization>Democritus University of Thrace</organization>
      <address>
        <postal>
          <street>University Campus</street>
          <city>Komotini</city>
          <code>69100</code>
          <country>Greece</country>
        </postal>
        <email>vtsaousi@ee.duth.gr</email>
      </address>
</author>
<author fullname="Carlos Borrego" initials="C."
            surname="Borrego">
      <organization>Autonomous University of Barcelona</organization>
      <address>
        <postal>
          <street>Department of Information and Communications Engineering</street>
          <city>Bellaterra</city>
          <code>08193</code>
          <country>Spain</country>
        </postal>
        <email>carlos.borrego@uab.cat</email>
      </address>
</author>
<date day="15" month="March" year="2020" />

<abstract>
<t>
This draft describes the Data reAchaBility BasEd Routing (DABBER) protocol, which aims to extend the operation of distributed Information Centric Networking frameworks to opportunistic wireless networks such as Delay Tolerant Networks. By "opportunistic wireless networks" it is meant multi-hop wireless networks where finding an end-to-end path between any pair of nodes at any moment in time may be a challenge. The goal is to assist in better defining opportunities for the transmission of Interest and Data packets in a store-carry-and-forward manner, based on a combination of proactive and reactive approaches. The document presents an architectural overview of DABBER followed by the specification of the proactive approach based on the dissemination of name-prefix information, and the reactive approach based on the encounters probability.
</t>
</abstract>

</front>
 

<middle>
<section title="Introduction"> <!-- 1 -->
<t>In a networking scenario where an increasing number of wireless systems, such as end-user nodes and mobile edge nodes, are being deployed, there are two networking paradigms that are highly correlated to the efficiency of pervasive data sharing: Information-Centric Networking (ICN)<xref target="RFC7476"/>, and Delay tolerant Networking (DTN) <xref target="RFC4838"/>. The latter concerns the capability of exploiting any potential wireless communication opportunity to exchange data in a multi-hop wireless networks, where it is difficult to find an end-to-end path between any pair of nodes at any moment in time.
</t>
<t>Combining ICN and DTN is relevant to efficiently extend the applicability of information-centric networking to novel scenarios, such as affordable pervasive access; low cost extension of access networks; edge computing; vehicular networks.
</t>
<t>This document describes the Data reAchaBility BasEd Routing (DABBER) routing protocol aiming to support information-centric delay-tolerant networks (ICDTN) <xref target="ICN-routing-opp"/>. These networks are operationally located on the Internet fringes. In such areas, networking experiences intermittent connectivity and variable availability of nodes due to their movement and/or due to other constrains, e.g., limited battery, storage, and processing. 
</t>
<t>It is our understanding that routing in such wireless environments needs to be done based on strategies that take into consideration, at a network level, the context of wireless nodes (e.g. availability, centrality), and not just the history of contacts among wireless nodes. The goal is to assist in better defining opportunities for the transmission of Interest and Data packets over time and space: DABBER focus on a data plane similar to the one use by CCN/NDN <xref target="NFD"/>, since these are well established distributed ICN frameworks. 
</t>
<t>DABBER brings ICN and DTN together by combining a proactive approach to forward Interest packets based on the dissemination of name-prefix information, with a reactive approach to forward Data packets based on information collected about custodians and based on encounters probability. The dissemination of name-prefixes and the dissemination of Data packets is done based on the context of nodes, and not just the history of contacts among wireless nodes.
</t>

<section title="Applicability"> <!-- 1.1-->
<t>DABBER is being developed to allow the deployment of ICDTN where nodes and links can be intermittently available, such as in the case of emergency situations <xref target="NDN-emergency"/>. From an end-to-end perspective we can consider two scenarios: the NDN wireless network is at the fringes of the NDN core; the NDN wireless network can interconnect different NDN fixed networks.
</t>
<t>While the latter may support applicability scenarios typical of Delay-Tolerant Networks (DTN) for instance tunneling traffic over an area lacking network deployment, the former allows the extension of the applicability of information-centric networking to novel scenarios such as affordable pervasive data access, low cost extension of access networks, edge computing, and vehicular networks:
</t>
<t>Affordable pervasive data access:
This scenario encompasses the implementation of NDN in personal mobile nodes (e.g. smartphones) allowing users to share data and messaging services by exploiting existing intermittent wireless connections (e.g. Wi-Fi, Wi-Fi direct) in environment without/or limited Internet access.
</t>
<t>Low cost extension of access networks:
This scenario refers to the usage of wireless nodes (mobile or fix) to extend the reach of an NDN networks while reducing CAPEX costs.
</t>
<t>Edge/Fog computing:
This scenario is related to the efforts being done to bring cloud computing closer to the end-users. This scenario encompasses a large set of heterogeneous (wireless and sometimes autonomous) decentralized nodes able of communicating, directly or via an infrastructure, in order to perform storage and processing tasks without the intervention of third parties. This scenario deals with nodes that might not be continuously connected to a network, such as laptops, smartphones, tablets and sensors, as well as nodes that may be intermittently available due to scarce resources, such as wireless access routers and even Mobile Edge Computing (MEC) servers.
</t>
<t>V2X networks:
This scenario deals with the intermittent connectivity between vehicles as well as between vehicles and the infrastructure.
</t>
</section> <!-- ends: "1.1 -->

<section title="Assumptions and Requirements"> <!-- 1.2-->
<t>DABBER relies on the following assumptions:
</t>
<t>o Mobile nodes are able of exploiting wireless connectivity.
</t>
<t>o Mobile nodes can be a source and destination of data, being able of operating as a router: there is not a clear distinction, in terms of routing process, between sources, destinations, and routers.
</t>
<t>o Mobile nodes may decide to be the custodians of data transmissions based on a set of criteria such as local available resources.
</t>
<t>o In DTNs it is not possible to know the complete network topology.
</t>
<t>o In DTNs it is not efficient to flood the network, as shown by all prior solutions based on controlled packet replication forwarding (<xref target="RFC6693"/><xref target="Dlife"/><xref target="Scorp"/><xref target="Dlife-draft"/>) instead of broadcast as used in Epidemic routing.
</t>
<t>o Selecting the best set of neighbors to replicate packets to, may not be efficient if based only on connectivity based information (e.g. inter-contact times, contact duration).
</t>
<t>In terms of requirements:
</t>
<t>o Routing informaiton must be exchanged based on Interest / Data messages.
</t>
<t>o Routing information should be used to distribute only name prefix reachability, since building a network topology based on adjacency information is not feasible in an opportunistic network.
</t>
<t>o Routing information must be distributed to multiple next-hops based on local information that encodes data reachability.
</t>
<t>o A synchronization mechanism my be used to exchange routing information among neighbor node.
</t>
<t>o Forwarding of Interest packets must take into account the information stored in the Forwarding Information Base (FIB).
</t>
<t>o Interest packets must carry information about the data consumer ID.
</t>
<t>o Interest packets should carry information about custodians IDs.
</t>
<t>o Forwarding of Interest must take into account the information stored in the Forwarding Information Base (FIB).
</t>
<t>o Forwarding of Data packets must take into account the information stored in the Pending Information Table (PIT).
</t>
<t>o The PIT must store information about the data consumer ID.
</t>
<t>o The PIT may store information about custodians IDs.
</t>
<t>o Data sources must set the validity of name prefixes - validity v - as an integer that represents the expiration date of the data.
</t>
</section> <!-- ends: 1.2-->

<section title="Conventions "> <!-- 1.3-->
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.
In this document, these words will appear with that interpretation only when in ALL CAPS. Lower case uses of these words are not to be interpreted as carrying significance described in RFC 2119.
</t>
</section> <!-- ends: "1.3-->
</section> <!-- ends: "1 -->


<section title="DABBER Architecture"> <!-- 2 -->
<t>This section presents an overview of the DABBER protocol architecture. DABBER relies on the same message formats, message exchange process, and same data structures made available by CCN/NDN: Routing Information Base (RIB); Forwarding Information Base (FIB); Pending Intent Table (PIT), while adding new elements such as two new faces (OPPFace and DTNFace), a contextual manager, and distinct forwarding strategies for Interests and Data packets. On contrary to what happens in CCN/NDN, in DTN Data packets may not be able to follow the same path followed by Interest packets.
</t>
<t> 
<figure>
<artwork>            TBD

</artwork>
</figure>
</t>
<t>
                 Figure 1: DABBER Architecture.
</t>

<section title="Routing and Forwarding"> <!-- 2.1 -->
<t>DABBER aims to assist in better defining opportunities for the transmission of Interest and Data packets in a store-carry-and-forward manner, based on a combination of proactive and reactive approaches. DABBER defines a proactive routing approach based on the dissemination of name-prefix information, which are use to identifie suitable next hops to reach a certain data object. This location can be the source of data or any other custodian. The proactive routing scheme aims to reduce the time needed to reach the requested data object. Without a mechanism able of disseminating routing information, devices would need to use try and error approach based on a broadcast forwarding strategy. Besides the extra delay in finding the requested data, such strategy will increase the amount of used networked resources. As shown in figure 2, the proposed proactive approach is able of populating the FIB with a list of next hops towards each name prefix. This is done based on the information collected from neighbor nodes and stored in the RIB.
</t>
<t> 
<figure>
<artwork>    Node A                Node B
          +----------+          +------------+
     N -  |1        2| - N----- |1          2|
          |          |          |            |
          |3        4| - N      |3          4|
          +----------+   |      +------------+
                         |         Node C
                         |       +------------+
                          ------ |1          2|
                                 |            |
                                 |3          4|
                                 +------------+

             RIB                                  FIB                
        +----------------------------+      +-----------------------+
        |Prefix Name | Face   | Cost |      | Prefix Name |  Faces  |
        +----------------------------+      +-----------------------+
        |     N      |  2     |  3   |      | N           |  2,1,4  | 
        |     N      |  4     |  10  |      |             |         |  
        |     N      |  1     |  5   |      +---------------------- +
        +----------------------------+

               PIT
       +--------------------------------------------+
       | Interest |  Face  | Requester | Custodians |
       +--------------------------------------------+
       |   N      |    1   |    DID1   |  DID2;DID3 | 
       |          |    3   |    DID4   |            |  
       +--------------------------------------------+


</artwork>
</figure>
</t>
<t>
                 Figure 2: RIB, FIB and PIT on node A.
</t>

<t>The FIB illustrated in Figure 2 is used by a forwarding strategy (c.f. section 4.1) used to transmit Interest packets in the direction of one of more copies of the requested data. This strategy is perfectly aligned with the current CCN/NDN architecture. However the same does not happen with the forwarding of Data packets. On CCN/NDN Data packets are transmited in the Faces listed in the PIT for the name carried in the Data packet. Although this breadcumb approach works on a stable/fixed network, the same does not happen in a DTN, since faces from which Interest packets were received may be down. In this case DABBER forwards Data packets toward the DID of the data requester (mandatory), or to any identified custodian (Optional). This is done by using new forwarding strategy for Data packets based on the encounters probability and contextual awareness, as described in section 4.2. 
</t>
<t>The inclusion of a forwarding strategy for Data packets is already a difference from the CCN/NDN architecture. To implement such forwarding strategy some changes need to be included to handle Interest packets (c.f. section 4.1) and to the PIT structure, namely:
</t>
<t>o The Interest packet includes the DID of the requester device, as well as of any visited custodian device. For this the ApplicationParameter optional field can be used.
</t>
<t>o The in-record of the PIT entry related to the Interest needs to hold the following fields: DID of resquester; list of DID of custodians, as illustrated in Figure 2.
</t>
<t>Given the multi-path nature of DABBER, the incoming Face might appear among the potential next-hops for a given name prefix. For this reason, DABBER applies the Incoming Face Exclusion principle <xref target="Loop-free"/> in order to prevent forwarding packets back though the Face them came from, thus removing two-hop loops. 
</t>
<t>Furthermore, in order to detect longer forwarding loops (more than two hops), DABBER relies on the nonce-based detection scheme available in CCN/NDN in order to drop a looping packet as soon as it is received the second time. 
</t>
<t>In addition, DABBER considers a loop removal mechanism, which takes care of disabling the Face responsible for the looping once it is detected.
</t>
</section> <!-- ends: 2.1-->

<section title="Contextual Awareness"> <!-- 2.2 -->
<t>DABBER defines routing and forwarding strategies that take into consideration, at a network level, the context of wireless nodes, and not just the history of contacts among wireless nodes. Contextual information is obtained in a self-learning approach, by software-based agents running in each networked device, and not based on network wide orchestration. Contextual agents are in charge of computing node and link related costs concerning availability and centrality metrics. Contextual agents interact with DABBER via a well-defined interface: the contextual self-learning process is not an integrating part of the DABBER routing framework.
</t>
<t>The contextual agent (named Contextual Manager <xref target="UmobileD45"/>) installed in each device can therefore be seen as an end-user background service that seamlessly captures wireless data to characterize the affinity network (roaming patterns and peers' context over time and space) and the usage habits and data interests (internal node information) of a node. Data is captured directly via the regular MAC Layer (e.g., Wi-Fi, Bluetooth, LTE) as well as via native applications for which the user configures interests or other type of personal preferences. For instance, an application can request a one-time configuration of categories of data interests (e.g., music, food). 
</t>
<t>Based on the defined interface, DABBER is able of querying the local Contextual Manager about the characteristics of neighbor nodes, based on three types of information: i) Node availability (metric A); ii) Node centrality (metric C); iii)  Node similarity (metric S): 
</t>
<t>o Node Availability (A) gives an estimate of the node availability based on the usage of internal resources over time and space, such as the time spent per application category (e.g. per day), as well as the usage of physical resources (battery status; CPU status, etc).
</t>
<t>o Node Centrality (C) provides awareness about the node's affinity network neighborhood context. This means that a list is kepted with the following information about each neigbour: neighbour's node degree; Frequency of contacts between the neighbor and other nodes; Duration of each contact between the neighbor and other nodes; Importance of encountered nodes.
</t>
<t>o Node similarity (S) provides awareness about a node's similarity towards neighbor nodes. This means that a list is kepted with the following information about each neigbour: Packet Error Rate of the wireless link towards the neighbor; Frequency of contacts with neighbor; Duration of each contact with neighbour.
</t>
<t>The Contextual Manager keeps values for the mentioned metrics for different periods of time. Encountered nodes can be of different types, such as other mobile devices or wireless access points for instance.
</t>
</section> <!-- ends: 2.2-->


<section title="Device Identifiers"> <!-- 2.3-->
<t>With DABBER, networked devices (producers, consumers, routers) are identified by variable-length identifiers, such as End-points Identifiers in DTN and hierarchical names in CCN/NDN. Using an DID, a node is able to determine the source of a Interest packet as well as a potential set of custodians that may help the data transmission process. Each device is required to have at least one DID that uniquely identifies it.
</t>
<t>Device ID are expressed syntactically as a Uniform Resource Identifier (URI) <xref target="RFC3986"/>. The URI syntax has been designed as a way to express names or addresses for a wide range of purposes, and is therefore has been used to construct names for DTN endpoints, as well as hierarchical names in CCN/NDN. In URI terminology, each URI begins with a scheme name. The scheme name is an element of the set of globally-managed scheme names maintained by IANA. Lexically following the scheme name in a URI is a series of characters constrained by the syntax defined by the scheme. This portion of the URI is called the scheme-specific part, and can be quite general. 
</t>
<t>Being based on UIRs, device IDs may be kept quite flexible. They might, for example, be constructed based on DNS names, or might look like expressions of interest or intentional names. For instance DIDs may be set up to reflect the network operator to which the mobile node belongs to and to the home site, in case the mobile operator has more than one operational site. In this case, when a mobile node is used outside its home network and some of its requests reach an access point of a visited mobile network, the latter may recognize may be able of checking if there is a roaming agreement between the home network and one of the networks of the visited operator. If so the request may be routed towards an international transit network.
</t>
<t>Based on an URI scheme that may reflect a network operator, the information included in the DID may be used to select next hops belonging to the same operator network, or nodes that have the same home network. It is assumed that a DTN is build based on wireless direct connectivity between nodes that may belong to different operators, but that may have roaming patterns that allows them to have frequent wireless contacts.
</t>
</section> <!-- ends: "2.3-->

<section title="Faces"> <!-- 2.4-->
<t>DABBER leverages the concept of Faces in CCN/NDN to adapt its operation to the intermittent property of wireless connections. This is done by the implementation of two new type of faces, called Opportunistic Face (OPPFace) and Delay Tolerant Networking Face (DTNFace). Besides these two communication interfaces, DABBER keeps a face to the Contextual Manager (CMFace).
</t>

<section title="OPPFace"> <!-- 2.4.1-->
<t>An OPPFace is based on a system of packet queues to hide intermittent connectivity: instead of dispatching packets from the FIB, the OPPFace is able of delaying packet transmission until the wireless face is actually connected. OPPFaces are kept in the Face Table of the forwarder and their state reflects the wireless connectivity status: they can be in an Up or Down state, depending upon the wireless reachability towards neighbor nodes. Based on this information, the OPPFace decides whether to simply queue packets (when OPPFace is down) or flush the queue (when OPPFace is up). Since packet queuing is concealed inside OPPFaces, existing forwarding strategy do not need to be changed.
</t>
<t>OPPFaces can be implemented by using any direct wireless communication mode. The current specification of DABBER considers Wi-Fi (Infrastructured, Ad-Hoc, and Direct mode). 
</t>
<t>The current version of the NDN port to opportunitic networks based on Android (NDN-OPP) makes usage of group communications provided by Wi-Fi Direct <xref target="NDN-OPP"/><xref target="NDN-opportunisticnets"/> (<eref target="https://github.com/COPELABS-SITI/ndn-opp">NDN-OPP GitHub code</eref>). In this case there is a one-to-one correspondence between an OPPFace and a neighbor node (for each node detected in a Wi-Fi Direct Group, a new instance of an OPPFace is created). In this peer-to-peer scenario, OPPFaces can be used in two transmission modes: connection-oriented, in which packets are sent to a neighbor node via a reliable TCP connection over the group owner; connection-less, in which packets are sent directly to a neighbor node during the Wi-Fi direct service discovery phase. In the latter case data transmission is limited to the size of the TXT record (900 bytes for Android 5.1 and above). This type of communication is used to exchange small packets that require fast transmission (e.g. emergency apps, Chronosync status messages). The connection-less solution allows peers to exchange a short number of bytes without the establishment of a TCP socket.
</t>
<t>In the peer-to-peer scenario of Wi-Fi direct, DABBER operates as follows: routing information is shared among all members of a Wi-Fi direct group, while Interest Packets are forwarded to specific neighbors. With Dabber it is the carrier of an Interest packet that decides which of the neighbors will get a copy of the Interest packet. Hence, with the current implementation of NDN-OPP, DABBER places a copy of the Interest packet in the OPPFaces of selected neighbors. In what concerns the dissemination of routing information, it is ensured by: i) node mobility, meaning that nodes carry such information between Wi-Fi direct groups; ii) information is passed between neighbor groups via nodes that belong to more than one group.
</t>
<t>Based on the reception of notifications of Wi-Fi Direct regarding changes in the peers detected in the neighborhood, DABBER is able of updating its internal peer list (Neighbor Table as illustredted in Figure 5). If it is not currently connected to a Wi-Fi Direct Group, it performs a selection heuristic to determine which node to connect to. The motivation behind this selection process is to attempt to minimize the number of Wi-Fi Direct Groups in a certain area given that nodes can only transmit packets within the Group they are currently connected to.
</t>
<t>By defining OPPFaces implemented based on a broadcast link layer such as ad-hoc Wi-Fi, DABBER will need to create only one OPPFace in each networked device. Such OPPFace would be used to exchange packets with any neighbor node, making use of the overhearing property of the wireless medium. Since with DABBER, it is the carrier that decides which of the neighbors are entitle to get a certain Interest packet, DABBER would need to encode in the Interest packet information about the ID of the neighbors that should process the overheard Interest packet.
</t>
</section> <!-- ends: "2.4.1-->

<section title="DTNFace"> <!-- 2.4.2-->
<t>By defining a DTNFace implemented based on the bundle layer <xref target="RFC5050"/> DABBER will make use of the end-to-end protocol, block formats, and abstract service description for the exchange of messages (bundles) described in the DTN architecture. A DTNFace provides a robust communications platform for the transmission of Data packets towards the consumer node, making usage of any available custodian nodes.
</t>

<t>The bundle protocol <xref target="RFC5050"/> introduces the concept of a "bundle agent" that manages the interface between applications and the "convergence layers" that provide the transport of bundles between nodes during communication opportunities. DABBER defines a DTNFace that extends the bundle agent aiming to control the actions of the bundle agent during communication opportunities. 
</t>
<t>The new DTNFace aims to control the reception and delivery of bundles, which are placed in a queue during the forwarding of Data packets. The DTNFace allows the routing process to be aware of the bundles placed at the node, and allows it to inform the bundle agent about the bundles to be sent to a neighbor node. Therefore, the bundle agent implemented in the DTNFace needs to provide the following interface/functionality to the forwarding process:
</t>
<t>Get Bundle List: Returns a list of the stored bundles and their attributes to the routing agent.
</t>
<t>Send Bundle: Notifies the bundle agent to send a specified bundle.
</t>
<t>Drop Bundle Advice: Advises the bundle agent that a specified bundle may be dropped by the bundle agent if appropriate.
</t>
<t>Acked Bundle Notification: Bundle agent informs routing agent whether a bundle has been delivered to its final destination and time of delivery.
</t>
</section> <!-- ends: "2.4.2-->

<section title="CMFace"> <!-- 2.4.2-->
<t>TBD
</t>
</section> <!-- ends: "2.4.2-->
</section> <!-- ends: 2.4-->
</section> <!-- ends 2 -->

<section title="Routing of Name Prefixes"> <!-- 3-->
<t>Being developed to operate in DTNs, DABBER does not rely on the dissemination of Adjacency Link State Advertisements (LSAs) that reflect the status of the links towards neighbor nodes; DABBER only requires the dissemination of Prefix LSAs, and does not require the computation of shortest paths. DABBER replaces the path cost used by protocols used for fixed networks with a data reachability cost reducing the impact that topological changes would have on the stability of routing information.
</t>
<t>The computation of data reachability costs towards different data sources, based on the local dissemination of name prefixes, aims to avoid flooding the wireless network with Interest packets that would otherwise be broadcast to all potential data sources.
</t>

<section title="LSA Dissemination "> <!-- 3.1-->
<t>DABBER makes use of Interest/Data packets to have neighbour devices exchanging Prefix LSAs. This means that while IP-based routing protocols push updates to other routers, DABBER devices pull updates. DABBER can use any underlay communication channels (e.g., TCP/UDP tunnels, Link layer TXT records) to exchange LSA information. 
</t>
<t>By using Interest/Data packets, DABBER benefits from CCN/NDN built-in data authenticity to exchange routing information: since a routing update is carried in an Data packet and every Data packet carries a signature, a DABBER device can verify the signature of each LSA to ensure that it was generated by the claimed origin node and was not tampered during dissemination.
</t>
<t>DABBER advertises Prefix LSAs every time a new name prefix is added or deleted to the LSA Data Base (LSDB). Name prefixes are advertised with a cost metric related to the validity of the associated data, as shown in Figure 3. Each LSA used by DABBER has the name &lt;DID&gt;/DABBER/LSA/Prefix/&lt;version&gt;. The &lt;DID&gt; is described by a scheme based on URIs (c.f. section 2.1); It can be for instance &lt;network&gt;/&lt;operator&gt;/&lt;home&gt;/&lt;node&gt;/. The &lt;version&gt; field is increased by 1 whenever a device creates a new version of the LSA.
</t>
<t> 
<figure>
<artwork>
        Prefix LSA
  +-----------------------------------------------------------------+
  |  LSA  | Number of |Prefix 1|Cost| ... |Prefix N|Cost| Signature |
  |  Name | Prefixes  |        |    |     |        |    |           |
  +-----------------------------------------------------------------+
</artwork>
</figure>
</t>
<t>
                 Figure 3: Prefix LSA format.
</t>

<t>DABBER disseminates LSAs via a data synchronization mechanism (e.g. ChronoSync <xref target="ChronoSync"/>, PartialSync <xref target="PartialSync"/>) of the local LSDB. This peer synchronization approach is receiver-driven, meaning that a device requests LSAs only when it has CPU cycles. Thus it is less likely a device will be overwhelmed by a flurry of updates. In order to reduce the amount of transfered data, DABBER removes obsolete LSAs from the LSDB by periodically refreshing each of its own LSAs by generating a newer version. Every LSA has a lifetime associated with it and will be removed from the LSDB when the lifetime expires.
</t>
<t>DABBER performs the dissemination of LSAs based on a process able of synchronizing the content of LSDBs. In this sense, all LSAs are kept in the LSDB as a name set, and DABBER uses a hash of the LSA name set as a compact expression of the set. Neighbor nodes use the hashes of their LSA name sets to detect inconsistencies in their sets. For this reason, neighbor nodes exchange hashes of the LSDB as soon as OPPFaces are UP.
</t>
<t>Current version of DABBER makes use of ChronoSync as synchronization mechanism. Chronosync allows DABBER to define a collection of named data in a local repo as a slice. LSA information is synchronized among neighbor nodes, since Chronosync keeps the repo slice containing the LSA information in sync with identically defined slices in neighboring repositories. If a new LSA name is detected in a repo, ChronoSync notifies DABBER to retrieve the corresponding LSA in order to update the local LSDB. DABBER can also request new LSAs from Chronosync when resources (e.g. CPU cycles) are available.
</t>
<t>Figure 4 shows how an LSA is disseminated between two neighbor nodes A and B, when the OPPFace is UP. To synchronize the slice representing the LSDB information in the repo, ChronoSync, on each node, periodically sends Sync Interests with the hash of its LSA name set / slice (step 1). When Node A has a new Prefix LSA in its LSDB, DABBER writes it in the Chronosync slice (step 2). At this moment, the hash value of the LSA slide of node A becomes different from that of node B. As a consequence, the Chronosync in node A replies to the Sync Interest of node B with a Sync Reply with the new hash value of its local LSA slice (step 3). The Chronosync in node B identifies the LSA that needs to be synchronized and notifies DABBER about the missing LSA, and updates its LSA name set (step 4). Since DABBER on node B has been notified of the missing LSA, DABBER sends an LSA Interest message to retrieve the missing LSA (step 5). DABBER on node A sends the missing data in a LSA Data message (step 6).  When DABBER on node B receives the LSA data, it inserts the LSA into its LSDB. Chronosync on nodes A and B compute a new hash for updated the set and send a new Sync Interest with the new hash (step 7).
</t>
<t>
<figure>
<artwork>  

       Node A                            Node B
  +----------------------------+     +----------------------------+
  |            +-------------+ |     |+-------------+             |
  |    DABBER  |  Chronosync | |     ||  Chronosync |   DABBER    |
  |            +-------------+ |     |+-------------+             |
  +----------------------------+     +----------------------------+
         |            |  Sync Interest (1) |              |
         |            |-------------------&gt;|              |
         |            |&lt;-------------------|              |
         | New LSA (2)|                    |              |
         |----------&gt; |                    |              |
         |            |    Sync Reply (3)  |              |
         |            |-------------------&gt;|              |
         |            |                    |  Notify (4)  |
         |            |                    |-------------&gt;|
         |            |   LSA Interest (5) |              |
         |&lt;-----------|--------------------|--------------|
         |            |   LSA Data (6)     |              |
         |------------|--------------------|-------------&gt;|
         |            |                    |              |
         |            |  Sync Interest (7) |              |
         |            |-------------------&gt;|              |
         |            |&lt;-------------------|              |

</artwork>
</figure>
</t>
<t>
                 Figure 4: LSA exchange process.
</t>


<t>When more than one LSA needs to be synchronized, the issued LSA Interest packet will contain information about as many LSAs as allowed by the Link maximum transmission unit. In the same sense one LSA Data packet may include also be used to transport information about more than one LSA.
</t>
</section> <!-- ends: 3.1 -->


<section title="Multiple path Computation "> <!-- 3.2-->
<t>By exchanging LSAs each devices becomes aware of potential next-hops via which a name prefix N can be reached with a certain cost k. This cost k represents the probability of reaching a data object identified by N via a Face F, and is related to the time validity of the name prefix (v). The rationale for this approach is that the selection of faces that have a lower cost k (higher validity v) will improve data reachability. The validity of a name prefix is set by the data source as an integer that represents the expiration date of the data.
</t>
<t>Since different devices can announce the same name prefix, a certain name prefix may be associated with different values of k (as v shall differ) over different faces, depending upon the nodes announcing such name prefix: this lead to the identification of multiple next hops, each one with a different cost.
</t>
<t>The computation of multiple next hops is performed every time DABBER has a new Name Prefix LSA (or a new version of an existing Name Prefix LSA) in its LSDB. The sequence of operations, as described in the following sub-sections are:
</t>
<t>1) Computes a new value for the validity of a new Name Prefix in the LSDB; 
</t>
<t>2) Updates DABBER internal routing table; 
</t>
<t>3) Updates the LSDB with the data reachability information (validity) of the current node towards the new Name Prefix; 
</t>
<t>4) Updates the RIB on NDF based on the DABBER internal routing table, following a Downwards Path Criterion (FIB is updated by NFD based on the RIB content). 
</t>
<t>Periodically DABBER updates the validity values of all Name Prefixes in its internal routing table, performing the consequent updates of the local LSDB and RIB, and needed.
</t>

<section title="Name Prefix Cost Computation"> <!-- 3.2.1-->
<t>When DABBER is notified that a new Prefix LSA was registered in the LSDB or an existing Prefix LSA has a new version, it computes a new cost for each name prefix in such Prefix LSA. The cost of a name prefix is given by its validity.
</t>
<t>DABBER starts by computing a new validity v for a prefix N depending upon the validity announced by the neighbor, and the relevancy of the "relation" between the two neighbor nodes (e.g., node A and node B). The cost of the Name Prefix, passed to NFD, will then be computed as an inversely proportional value to its validity.
</t>
<t>The relevancy of the "relation" between two neighbor nodes can be, e.g., a measure of similarity <xref target="UmobileD45"/>, where similarity is seen as a link measure, i.e., it provides a correlation cost between a node and its neighbors. Or such relation can be weighted based on metrics derived from average contact duration thus allowing a node to adjust the Name Prefix validity based on the probability of meeting the respective neighbor again. The "relation" between two neighbor nodes is computed based on the three metrics (A, C, and S) provided by the local contextual manager, plus a metric computed by DABBER itself: the time reachability.
</t>
<t>The variable considered by DABBER for the computation of the validity/cost of a Name prefix passed by a neighbor Na are:
</t>
<t>o Validity (V) - Represents the expiration date of the data associated with the Name Prefix. Currently it is the UNIX Timestamp (10 digit integer).
</t>
<t>o Similarity metric (S) towards the neighbor Na, as passed by the contextual manager (S &gt;= 0), aiming to select neighbors with whom the current node has a good communication link.
</t>
<t>o Availability metric (A) towards the neighbor Na, as passed by the contextual manager ( 0 &lt; A &lt; 1), aiming to select neighbors able to process Interest packets with high probability.
</t>
<t>o Centrality metric (C) towards the neighbor Na, as passed by the contextual manager ( C &gt;= 0), aiming to select neighbors with high probability of successfully forwarding Interest packets.
</t>
<t>o Time reachability (T) which corresponds to the RTT between sending an Interest packet towards the source of such Name Prefix and receiving a data packet. (0 &lt; T &lt; 1). Currently the value of T is computed as (current time when data packet of received - time when Interest packet was sent) / Validity of Name Prefix. Time reachability allows DABBER to select next hops that lead to closer sources.
</t>

<t> 
<figure>
<artwork> 
          Neighbor table
  +------------------------------------------------------+
  |   Face     | Status | Metric C | Metric A | Metric S |
  +------------------------------------------------------+
  |     1      |    UP  |    6     |   0.3    |    12    |
  |     2      |  DOWN  |    4     |   0.8    |    8     |
  |     3      |    UP  |    1     |   0.8    |    9     |
  +------------------------------------------------------+       
</artwork>
</figure>
</t>
<t>
                 Figure 5: Neighbor table.
</t>

<t>The values C, A and S provided by the contextual manager are stored in a Neighbor Table (c.f. Figure 5) indexed by the number of faces. The higher the values of C, A and S, the most preferential a neighbor is.
</t>
<t>T is measured by observing the flow of Interest and Data packets. Thus, the lowest the T, the most preferential a Face is. Although different nodes may have a different implementation of a face ranking logic, the relevancy of T in comparison to C and A should be higher, since T reflects the measured delay to reach a data source, while C and A are indicators of the neighbors potential as relays.
</t>
<t>Based on the above mentioned metrics the Validity of a new Name Prefix (V) is updated based on two operations:
</t>
<t>o V' = f (V, S') = trunc (V * S'), where:
</t>
<t>    S' = (S - Smin) / (Smax - Smin); Smin = 0 and Smax = max (Smax, C)
</t>
<t>o V'' = f (V', C', A, T) = 0.3* trunc (V' * (C'+A)) + 0.7 * trunc (V' * T), where:
</t>
<t>     C' = (C - Cmin) / (Cmax - Cmin); Where Cmin = 0 and Cmax = max (Cmax, C)
</t>
</section> <!-- ends: 3.2.1-->

<section title="Update of DABBER internal routing table and LSDB"> <!-- 3.2.2-->
<t>After the computation of the cost of the Name Prefix taking into account the relation of the current node with the neighbor announcing it, DABBER updates its internal routing table and its LSDB. The information on the routing table will be used to updated the RIB of the local NFD and the information of the LSDB will be announced to all neighbors by Chronosync.
</t>
<t>To update the Internal routing table, DABBER adds an entry (Na, V'') for the Name Prefix received from Na, where V'' is the computed cost of the name prefix (c.f. section 3.2.1). The routing table is then ordered by name prefix in decreased order of validity.
</t>
<t>Since the current node will also disseminate the received Name Prefix, DABBER updates the cost of the Name Prefix in the LSA stored in its local LSDB in order to consider the computed value V''. For this, DABBER can use two methods:
</t>
<t>o Maximal method: Cost of Name Prefix = max (V'', current cost on LSA).
</t>
<t>o Average method: Cost of Name Prefix = max (average (cost of Name Prefix entries on local routing table), current cost on LSA).
</t>
</section> <!-- ends: 3.2.2-->

<section title="Update of RIB on NFD"> <!-- 3.2.3-->
<t>After computing the new value of the cost of a name prefix (c.f. section 3.2.2), DABBER updates the RIB entry of that name prefix with the face over which the Name Prefix LSA was received and the new computed cost. The cost (k) of the Name Prefix to be stored in the RIB is computed based on its validity V'' as k = trunc (100/V'').
</t>
<t>DABBER updates the RIB on NFD with the cost k based on three possible logics:
</t>
<t>o Increase diversity - The new Face is included in the RIB entry, if the computed cost k helps to increase diversity of the name prefix. For instance the new cost k is higher than the average costs already stored for that name prefix, affected by a configured diversity constant. This is, this logic include all neighbors with cost = trunc (100/V''), such that 1/V'' - Avr (Costs in RIB for N) &gt; X (predefined value).
</t>
<t>o Downward Path Criterion - It is a non-equal cost multi-path logic that is guaranteed to be loop-free. Based on the Downward Path Criterion, the X faces (the maximum number X of desirable faces can be defined by configuration) to be considered for a name prefix include the one with the lowest cost k plus X-1 faces that have a cost k lower than the cost that the current node has itself to the name prefix. This is, this logic includes X neighbors with cost = trunc(100/V''), such that cost is the lowest value of 1/V'' or cost &lt; 1/ V.
</t>
<t>o Downward Path Criterion extension - Also considers any face over which the name prefix can be reached with a cost k equal to the cost that the current node has itself to the name prefix. To avoid packet from looping back, there is the need to add a tiebreaker, which assures that traffic only crosses one direction of equal-cost links. This is, this logic includes X neighbors with cost = trunc (100/V''), such that cost is the lowest value of 1/V'' or cost &lt;=1/ V.
</t>
</section> <!-- ends: 3.2.3-->
</section> <!-- ends: 3.2-->

<section title="Routing Operation Example"> <!-- 3.3-->
<t>In order to illustrate the proactive routing method defined by DABBER, let's consider Figure 4, where nodes A, B, and C reside in an ICDTN running DABBER, while nodes E and F are wireless edge routers running another ICN routing protocol; G is a wireless node running DABBER.
</t>
<t> 
<figure>
<artwork> 
     +--------------------+
     |    +---+           |
     |    | B | .         |
     |    +---+  .2+---+  |   +---+    +---+     +---+
     |+---+        | C |3 ... | E |....| F  |....| G |
     || A |.......1+---+  |   +---+    +---+     +---+
     |+---+               |
     +--------------------+
</artwork>
</figure>
</t>
<t>
                 Figure 6: End-to-end operational example.
</t>

<t>In our example, Node A starts producing some content derived, for instance, from the use of an application (such as a data sharing application). The produced content is stored in its local Content Store with the name /NDN/video/Lisbon/nighview.mpg. Node B stores in its Content Store a data object with name /NDN/video/Lisbon/river.mpg, which node B received from a neighbor (meaning that B have already synchronize its LSDB with such a neighbor).
</t>
<t>Due to the update of the Content Store, the name prefix /NDN/video/Lisbon/ is stored in the LSDB of node A and B with a validity of 864000 and 518400 in the case of node A and B respectively. In the case of node A, the cost k of the name prefix equals the validity v of the data object, e.g., v=864000 seconds (10 days) stipulated by the application. In the case of node B the validity is the result of the computation process described in section 3.2.1.
</t>
<t>From a routing perspective, storing a name prefix in the local LSDB allows the node to share the respective Prefix LSA on all its Faces, excepting on the Face over which the LSA was previously received. This LSA exchange is done when the OPPFaces are up. This means that Node C, which got a new Prefix LSA from nodes A and B, will:
</t>
<t>o Update its LSDB with the Prefix LSAs received from node A and node B.
</t>
<t>o Update its internal routing table with two new entries for the name prefix /NDN/video/Lisbon/, associated with the face towards A (face1) and with the face towards B (face2), after computing the values of V' and V'' for the received validity values:
</t>
<t>o The validity of the name prefix is updated based on the metric configured for node C: average inter-contact time.
</t>
<t>o Let's assume that A and C encounter each other frequently, while B and C do not meet frequently. This means that the two entries on the routing table of node C for prefix /NDN/video/Lisbon/ will have a validity/cost for A higher than the one for B.
</t>
<t>o Update its LSDB with the validity of the current node towards the Name Prefix following the maximal or average methods.
</t>
<t>o Update the RIB with one new entry for the name prefix /NDN/video/Lisbon/ with two faces (face 1 and face 2) with a cost inversely proportional to the validity of the Name Prefix.
</t>
<t>When node C gets in the range of router E (wireless edge router) it will exchange disseminate routing information, based on some interoperability issues need to be considered, as described in section 4.
</t>
</section> <!-- ends: 3.3-->
</section> <!-- ends 3-->

<section title="Forwarding of Interest Packets"> <!-- 4-->
<t>In order to support the new forward strategy for Data packets, devices need to collect information about the DID of the requester (mandatory) and of any potential custodian (optional). Therefore, when an Interest packet is received, the following operations need to be performed:
</t>
<t>o The DIDs found in the ApplicationParameter field of the Interest packet are placed in the PIT entry corresponding to the Face over which the Interest packet was received.
</t>
<t>o Before forwarding the Interest packet, DABBER will include the DID of the current device if this is a custodian. In this version the role of custodian is pre-configured. This may be revised to include other logics, that may consider the capabilities of the device (e.g. available storage; available energy).
</t>
<t>Interest packets are forwarded based on the information that is stored in the FIB, which is updated by the NFD based on information stored on the RIB. Independently of the used forwarding strategy, it has to respect the ranking of faces done by DABBER on the RIB. For instance an unicast forwarding strategy will use the most important face (lower cost), while a multicast forwarding strategy will use all the faces indicated for the name prefix.
</t>
<t>After selecting the best set of faces, a copy of the Interest packet is sent to the OPPFaces of the selected faces. The state of an OPPFace reflects the fact that the corresponding neighbor device is currently reachable or not. Based on this information, the OPPFace decides whether to simply queue the packet or attempt a transmission over the associated Opportunistic Channel.
</t>
<t>Based on the feedback provided by the wireless channel (e.g. Wi-Fi direct confirmation), the OPPFace can decide to remove the packet from the queue once it has been passed on to its intended peer. In case the packet was not passed to the intended peers, a new attend to forward the packet will be done as soon as the OPPFace is activated: the OPPFace integrates a mechanism to automatically flush the queue whenever the face is brought up upon detection of the corresponding peer being available.
</t>
</section> <!-- ends: 4-->

<section title="Forwarding of Data Packets"> <!-- 5-->
<t>By following the operation of CCN/NDN, Data packets are forwarded based in the information holded in the PIT: the ID of the Faces over which a copa of the Data packet must be transmitted. In a DTN network, this setup faces two problems: i) the Face(s) stored in the PIT may not be active since neighbour devices are not in range; ii) the breadcumb path may not be available, since in a dynamic network some of the devices visited by the Interest packet may not be reachable.
</t>
<t>To solve these two problems, DABBER makes usage of a new forwarding strategy for Data packets by making usage of information stored in the PIT (which is different from the standard information used by CCN/NDN) and by making usage of an opportunistic forwarding scheme aiming to bring the Data packet closer to the requester or to any available custodian.
</t>
<t>The new forwarding strategy works as follows:
</t>
<t>o First check if the Face(s) present in the PIT related to that Interest are active. The Data packet is sent to the OPPFace of each active Face. This is a procedure similar to the one used by CCN/NDN.
</t>
<t>o For all Faces that are not active (OPPFace is down), DABBER uses an algorithm similar to dlife <xref target="Dlife"/><xref target="Dlife-draft"/> to forward the Data packet closer to the requester or any custodian.
</t>
<t>For all OPPFaces that are not active, DABBER starts by collecting the DID of the requester of Data, as well as the DID from potential Custodian from the in-record PIT entry related to that Interest. Based on that information DABBER will forward the Data packet to any active neighbour that has high probability to meet any of these DIDs. This forwarding is done through a DTNFace, which will create a bundle based on the Data packet to be sent.
</t>
<t>To forward Data packets, DABBER applies a social opportunistic contact paradigm to decide whether bundle replication is feasible. Its decision is based on social weight (w_(x,y)) towards the bundle's destination or on the importance (I(x)) of the encountered node (i.e., potential next forwarder) in the system. 
</t>
<t>If the encountered node has better relationship with the bundle's destination than the carrier in a given daily sample, it receives a bundle copy, since there is a much greater chance for the encountered node to meet the destination in the future. If relationship to the bundle's destination is unknown, replication happens only if the encountered node has higher importance than the bundle's current carrier.
</t>
<t>In order to compute the social weight between nodes and their importance, DABBER uses parameters that are determined as nodes interact in the system. A brief explanation of these parameters is given below:
</t>
<t>o CD_(x,y): Refers to the contact duration between nodes, i.e., time nodes spent in the communication range of one another, which would allow them to exchange information. Within a given daily sample, different contacts can happen with varied lengths.
</t>
<t>o TCT_(x,y): Refers to the total contact time between nodes within a given daily sample. It is given by the sum of all CD_(x,y) in that specific daily sample.
</t>
<t>o AD_(x,y): Refers to the average duration of contacts for the same daily sample over different days. It is a Cumulative Moving Average (CMA) of the average duration, considering the TCT_(x,y) of the current daily sample and average duration in the same daily sample of the previous day, AD_(x,y)_old.
</t>
<t>o w_(x,y): Refers to the social weight between nodes at a given daily sample. It reflects the level of social interaction among such nodes throughout their daily routines.
</t>
<t>o I_(x): Refers to the importance of a node in the system. The importance is influenced by how well a node is socially related to other important nodes.
</t>
<t>o N_(x): Refers to the neighbor set of a node x, which it encountered in the current daily sample.
</t>
<t>o dumping factor (d): Refers the level of randomness considered by the forwarding algorithm.
</t>
<t>o daily sample (Ti): Refers to the time period in which the contact duration will be measured to determine social weight and node importance. 
</t>
<t>As nodes interact, their CD_(x,y) is collected and used to determine TCT_(x,y), AD_(x,y), w_(x,y), and I_(x) at the end of every daily sample. If DABBER is configured with a high number of daily samples, the social weight and node importance will be more refined. Thus, it is recommended the usage of twenty-four (24) daily samples representing each hour of the day: the first daily sample refers always to the zero hour of the day when the node is started.
</t>
<t>Being able to identify the current daily sample allows a proper computation of social weights and importance. Hence, in the case of node failure (e.g., node crash) or node shutdown (e.g., lack of battery), nodes need to know exactly in which daily sample they stopped interaction, and more importantly how many daily samples have elapsed since then (elapsed_ds). To guarantee that, the equation below is used:
</t>
<t>elapsed_ds = cnds * (ed - 1) + (cds - 1) + (cnds - lds)      (1)
</t>
<t>where:
</t>
<t>"cnds" is the configured number of daily samples.
</t>
<t>"ed"refers to the number of elapsed days.
</t>
<t>"cds" refers to the current daily sample (the one in which the node came back on).
</t>
<t>"lds" refers to last daily sample (in which the node failed or shut down).
</t>
<t>With this, the node knows how many daily samples have elapsed and can proceed with the update of social weights and importance to reflect the lack of interaction that happen in reality.
</t>

<section title="Time-Evolving Contact Duration"> <!-- 5.1-->
<t>The TECD utility function considers the duration of contacts (representing the intensity of social ties among users) and time-evolving interactions (reflecting users' habits over different daily samples).
</t>
<t>Regarding the notations used in the equations presented in this sub-section: sumk(...) denotes summation for k from 1 to n; sumj(...) denotes summation for j from i to i+t-1; sumy denotes summation from all y belonging to N(x). 
</t>
<t>Two nodes may have a social weight, w_(x,y), that depends on the average total contact duration they have had in that same period of time over different days. Within a specific daily sample Ti, node x has n contacts with node y, having each contact k a certain contact duration, CD_(x,y). At the end of each daily sample, the total contact time, TCT_(x,y), between nodes x and y is given by the equation below where n is the total number of contacts between the two nodes.
</t>
<t>TCT_(x,y) = sumk(CD_(x,y))    (2)
</t>
<t>The Total Contact Time between users in the same daily sample over consecutive days can be used to estimate the average duration of their contacts for that specific daily sample: the average duration of contacts between users x and y during a daily sample Ti in a day j, denoted by AD_(x,y) is given by a cumulative moving average of their TCT in that same daily sample, TCT_(x,y), and the average duration of their contacts during the same daily sample Ti on the previous day, denoted by AD_(x,y)_old, as shown in the equation below.
</t>
<t>AD_(x,y) = (TCT_(x,y)+(j-1)*AD(x,y)_old)/j    (3)
</t>
<t>The social strength between users in a specific daily sample Ti may also provide some insight about their social strength in consecutive k samples in the same day, i+k. This is what we call Time Transitive Property. This property increases the probability of nodes being capable of transmitting large data chunks, since transmission can be resumed in the next daily sample with high probability. 
</t>
<t>TECD is able to capture the social strength w_(x,y) between any pair of users x and y in a daily sample Ti based on the average duration AD_(x,y) of contacts between them in such daily sample and in consecutive t-1 samples, where t represents the total number of daily samples. When k>t, the corresponding AD_(x,y) value refers to the daily sample k-t. In the equation below the time transitive property is given by the weight t/(t+k-i), where the highest weight is associated to the average contact duration in the current daily sample, being it reduced in consecutive samples.
</t>
<t>TECD = w_(x,y) = sumj(t/(t+k-i)*AD_(x,y))     (4)
</t>
</section> <!-- ends: 5.1-->

<section title="TECD Importance"> <!-- 5.2-->
<t>As social interaction may also be modeled to consider the node importance, TECDi computes the importance, I_(x), of a node x (cf. equation below), considering the weights of the edges between x and all the nodes y in its neighbor set, N_(x), at a specific daily sample Ti along with their importance.
</t>
<t>TECDi = I_(x) = (1-d)+d*sumy(w_(x,y)*I_(y)/N_(x))    (5)
</t>
<t>TECDi is based on the PeopleRank function. However, TECDi considers not only node importance, but also the strength of social ties between bundle's current carrier and potential next hops. Another difference is that, with TECDi, the neighbor set of a node x only includes the nodes which have been in contact with node x within a specific daily sample Ti, whereas in PeopleRank the neighbor set of a node includes all the nodes that ever had a link to node x. Note that the level of randomness may vary with the application scenario. Unless previously experimented, it is suggested that dumping factor be set to 0.8.
</t>
</section> <!-- ends: 5.2-->

<section title="Forwarding strategy"> <!-- 5.3-->
<t>Independently of the application scenario, each node MUST employ a forwarding strategy. The first rule is that if the encountered node is the final destination of a bundle, the carrier SHOULD prioritize such bundles by employing the prioritized forwarding strategy, described below.
</t>
<t>We use the following notation for the description provided in this section. Nodes A and B are the nodes that encounter each other, and the strategies are described as they would be applied by node A.
</t>

<section title="Basic Strategy"> <!-- 5.3.1-->
<t>Forward the bundle only if w_(B,D) > w_(A,D) or I_(B) > I_(A)
</t>
<t>When two nodes A and B meet in any daily sample Ti, node A gets from node B: a) the updated list of all neighbors of B, including the social weights that B has towards each of its neighbors, as well as the importance of B; b) the list of the bundles that B is carrying (bundle identifier, plus Endpoint Identifier (EID) of the destination); c) the list of the latest set of bundles acknowledged to B (the size of the list of acknowledged bundles returned by B depends on the local cache size and policy). The information about the social weight, importance, bundle list, and acknowledged bundles received from node B are referenced in node A as w_(B,x)_recv, I_(B)_recv, bundleList(IDn, destinationEIDx)_recv, and ackedBundleList(IDn, destinationEIDx)_recv, respectively.
</t>
<t>For every bundle that A carries in its buffer, and i) is not carried by B, ii) has not been previously acknowledged to B, and iii) B has enough buffer space to store it, node A sends a copy to B if B has already encountered the bundle's destination D and its weight in w_(B,D)_recv is greater than A's weight towards this same destination D. Otherwise, bundles are replicated if I_(B)_recv is greater than A's importance in the current daily sample Ti.
</t>
<t>Finally, node A will update its own ackedBundleList and discard bundles that have already been acknowledged to node B.
</t>
</section> <!-- ends: 5.3.1-->

<section title="Prioritized Strategy"> <!-- 5.3.2-->
<t>Similar to the basic forwarding strategy, being the only difference the fact that prior to sending bundles, node A will first send those bundles that have node B as destination.
</t>
</section> <!-- ends: 5.3.2-->
</section> <!-- ends: 5.3-->
</section> <!-- ends: 5-->


<section title="Protocol Addictional Functionality"> <!-- 6-->
<section title="Adjustment to data source mobility"> <!-- 6.1-->
<t>As NDN uses a publish/subscribe communication model, where request resolution and data transfer are decoupled, it is especially relevant to solve the problem of data source mobility. Supporting data source mobility requires, first of all, finding the new location of the source each time data sources move, and, second, updating the name resolution system according to the new location, in order to maintain the consistency of NDN forwarding.
</t>
<t>This sub-section described a new feature of DABBER which follows a new reactive approach to face the challenges of the data source mobility and consistent forwarding in Mobile ICNs. To this end, DABBER is using the efficient dissemination method for Opportunistic Networks <xref target="Optimal-stopping"/> to efficiently discover data sources by replicating Interest messages in an efficient way that avoids network flooding.
</t>
<t>With this new feature the prospective forwarders for a given Interest message (which are denoted as discoverers) are limited in number and carefully selected in terms of three criteria:
</t>
<t>o Centrality: how well connected a node is in the network. The more central a node is, the bigger the chances are to find a data source.
</t>
<t>o Reliability: the likeliness a node does not drop messages. The more reliable a node is, the least probable is that the Interest message will be discarded.
</t>
<t>o Similarity: how alike the contacted candidate node is in terms of shared acquaintances. The less similar, the more likely is that it will find different nodes in the future.
</t>
<t>A combination of these three criteria defines a reward function (discoverer suitability) of an Optimal Stopping (OS) problem. If a node finds a new node with a certain value for the discoverer suitability it is difficult to know whether this value is a good one when compared with what a node could find in future contacts. This decision is not trivial: if a node chooses early-contacted discoverer candidates, good results are not guaranteed because selected discoverers could have a low discoverer suitability metric. On the other end of the spectrum, selecting late-contacted discoverer candidates does not guarantee either good
discoverer nodes since it is likely that good candidates with high discovery suitability values would be skipped.
</t>
<t>DABBER is so extended with the ability to perform an OS-based strategy that allows nodes to select the most suitable node among all of the contacted ones to forward the Interest message. This strategy relies on the existence of an optimal set of stopping values such that the nth discoverer node for a certain Interest message is the first contacted node which is the best of all the previously explored nodes, if the node has contacted the first stopping value. If this node is not found, then it will be the first node which is the second best of all the previous nodes, if the node has contacted the second stopping value, and so on. Otherwise, if these nodes are not found, then, the nth discoverer node will be the last nth node before reaching the last contacted node. This makes the dissemination of the Interest messages in Mobile NDNs efficient, even, and pervasive all over the network, increasing the delivery ratio while decreasing the network overhead.
</t>
</section> <!-- ends: 6.1-->
</section> <!-- ends: 6-->

<section title="Interoperability"> <!-- 7-->
<t>In this section we analyze the interoperability of DABBER with routing and forwarding mechanisms used in wired ICN networks, aiming to study how DABBER can help in ther interconnection of ICDTNs with wired ICN networks. We analyze the interoperability of DABBER with two potential configurations of an ICN access network based on: a routing protocol able of disseminating name prefix information; a broadcast based forwarding approach.
</t>

<section title="Interoperability with ICN routing"> <!-- 7.1-->
<t>DABBER LSA dissemination mechanism provides a good interoperability with ICN routing protocols based on link state, which normally exchange information about adjacency and name prefixes. In this scenario the specification used by DABBER ensures a good level of interoperability, since DABBER follows the same message structure and sequence used by such protocols, such as the Named Data Link State Routing Protocol (NLSR).
</t>
<t>However, when DABBER is executing the LSA dissemination procedure over a Wi-Fi face, towards an edge router it will ignore all notifications that Chronosync will send related to Adjacency LSAs.
</t>
</section> <!-- ends: 7.1 -->

<section title="Interoperability with broadcast based forwarding"> <!-- 7.2-->
<t>Broadcast-based forwarding is a common mechanism in the design of some networks, such as switched Ethernet and mobile ad-hoc networks. In CCN/NDN networks this means that NFD broadcasts Interest packets that do not match an entry in the FIB, inserting then into the FIB the forwarding path learned through observation of Data return paths. The main challenge in broadcast based forwarding schemes is the prefix granularity problem: determine the name prefix of an inserted FIB entry from the Data name. Several solutions exist <xref target="Self-learning"/>, including the announcements of name prefixes, as done by DABBER.
</t>
<t>In any case DABBER interoperability with such CCN/NDN networks relies on the following considerations:
</t>
<t>o When in contact with a wireless edge router, DABBER always forward Interest packet towards the Wi-Fi Face, even when the Interest packet does not match an entry in the FIB.
</t>
<t>o Interest packets received from a wireless edge router will not be broadcast. Interest packets will be forwarded if they match an entry in the FIB, or dropped otherwise.
</t>
</section> <!-- ends: 7.2-->
</section> <!-- ends: 7-->

<section title="Security Considerations"> <!-- 8-->
<t>DABBER follows the CCN/NDN security framework built on public-key cryptography, allows it to secure the exchange of routing messages, by being able of verifying the authenticity of routing messages, and ensuring the needed levels of confidentiality. Moreover, DABBER ensures the right level of privacy of the involved entities, who provide local information to support routing decisions.
</t>
<t>Routing security can be achieved not only by signing routing messages, but also by allowing the usage of multiple paths, as done by DABBER: when an anomaly is detected routers can retrieve the data through alternative paths.
</t>
<t>Besides the presented security and privacy considerations, the issue of Denial of Service (DoS) needs to be properly addressed. An example is when a malicious user sends a high rate of broadcast messages aiming to exhaust available forwarding resources.
</t>
<t>The remaining of this section provides initial insights about the methods used by DABBER to ensure the authenticity, confidentiality of the routing message exchange as well as the privacy of the involved entities. 
</t>

<section title="Authenticity"> <!-- 8.1-->
<t>DABBER routing messages are carried in Data packets containing a signature. Hence, a DABBER device can verify the signature of each routing message to ensure that it was generated by the claimed origin node and was not tampered with during dissemination. For this propose, DABBER makes use of a hierarchical trust model for routing to verify the keys used to sign the routing messages.
</t>
<t>Following the name structure described in section 2.3, DABBER can model a trust management as a five-level hierarch, although reflecting a different administrative structure: &lt;network&gt; represents the authority responsible by the international transit network allowing roaming services; &lt;operator&gt; represents the operator providing the mobile service; &lt;home&gt; represents the network site of the mobile operator where the node is registered; &lt;node&gt; represents the mobile equipment. Each node can create a DABBER process that produces LSAs.
</t>
<t>With this hierarchical trust model, one can establish a chain of keys to authenticate LSAs. Specifically, a LSA must be signed by a valid DABBER process, which runs on the same node where the LSA was originated. To become a valid DABBER process, the process key must be signed by the corresponding node key, which in turn should be signed by the registered home network of the network operator. Each home network key must be signed by the operator key, which must be certified by the network authority using the network key.
</t>
<t>Since keys must be retrieved in order to verify routing updates, DABBER allows each node to retrieve keys from its neighbors. This means that a DABBER node will use the Interest/Data exchange process to gathers keys from all its direct neighbors. Upon the reception of an Interest of the type /&lt;network&gt;/broadcast/KEYS each neighbor looks up the requested keys in their local key storage and return the key if it is found. In case a neighbor does not have the requested key, the neighbor can further query its neighbors for such key. The used key retrieval process makes use of a broadcast forwarding strategy, stopping at nodes who either own or cache the requested keys.
</t>
</section> <!-- ends: 8.1-->

<section title="Confidentiality"> <!-- 8.2-->
<t>Although being deployed under the control of an operator, DABBER allows its network to be extended beyond the reach of its infrastructure network, into scenarios where wireless communications between involved DABBER devices/router may be spoofed. Hence, DABBER requires routing data confidentiality to ensure the setup of a secure communication topology.
</t>
<t>DABBER basic approach relies on the usage of encryption to protect the confidentiality of routing messages. By taking advantage of the semantically meaningful names DABBER relies on approaches such as Named-based Access Control (NAC) <xref target="NAC"/>. NAC provides content confidentiality and access control based on a combination of symmetric and asymmetric cryptography algorithms, while using NDN's data-centric security and naming convention to automate data access control.
</t>
<t>Being implemented in wireless devices that may energy constraint, it will be important to verify the efficiency of the cryptographic solution, namely since the generation of asymmetric key pairs as well as the symmetric and asymmetric encryption/decryption operations may be expensive in terms of the usage of resources.
devices.
</t>
</section> <!-- ends: 8.2-->

<section title="Privacy"> <!-- 8.3-->
<t>In DABBER, forwarding decisions are taken into account using different metrics such as centrality and similarity. While these metrics may be efficient in terms of node selection, they can breach privacy of network users carrying networked devices by inferring social related information such as position inside groups, as well as information about the devices themselves.
</t>
<t>If exchanged as clear text, the information carried in routing metrics may potentially compromising the privacy of users. A way of preserving the privacy of the users in DABBER is to use NDN-P2F <xref target="Privacy"/>, a privacy-preserving forwarding scheme that uses homomorphic encryption for information-centric wireless Ad Hoc Networks.
</t>
<t>In, NDN-P2F, forwarding decisions are made by performing calculations on encrypted forwarding metric values without decrypting them first, while maintaining low overhead and delays. As a result, forwarding decisions can be taken preserving the user's privacy. For these purposes, homomorphic encryption is extremely useful. This cryptographic scheme allows computations on ciphertexts and generates encrypted results that, when decrypted, match the results of the operations as if they had been performed on plaintexts. 
</t>
<t>There are many homomorphic cryptosystems. A good choice for DABBER can be the Paillier cryptosystem because it is lightweight and, among its properties, it includes the homomorphic addition and multiplication of plaintexts and the homomorphic multiplication by a scalar. The Paillier cryptosystem, however, does not provide a way of calculating the encrypted subtraction, which is needed for metric comparisons. For these purposes, the mapping scheme proposed in <xref target="PrivHab"/> can be used to be able to operate with negative numbers.
</t>
</section> <!-- ends: 8.3-->
</section> <!-- ends: 8-->

<section title="IANA Considerations"> <!-- 9-->
<t>This document has no actions for IANA.
</t>
</section> <!-- ends: 9-->

<section title="Acknowledgments"> <!-- 10-->
<t>The research leading to these results received funding from the European Union (EU) Horizon 2020 research and innovation programmer under grant agreement No 645124(Action full title: Universal, mobile-centric and opportunistic communications architecture, Action Acronym: UMOBILE)<xref target="Umobile"/>.
</t>
<t>We thank all contributors, as well as the valuable comments offered by Lixia Zhang (UCLA) and Lan Wang (University of Memphis) to improve this draft.
</t>
</section> <!-- ends: 10-->

</middle>
<back>

<references title="Normative References">
<reference anchor="NFD" target="">
        <front>
            <title>NFD Developer's Guide</title>
            <author>
               <organization>A. Afanasyev, et al</organization>
            </author>
            <date month="October" year="2010" />
        </front>
        <seriesInfo name="NDN Technical Report NDN-001" value="" />
</reference>
<reference anchor="NDN-OPP" target="">
        <front>
            <title>NDN-Opp: Named-Data Networking in Opportunistic Networks</title>
            <author initials="M" surname="Tavares" fullname="Miguel Tavares"></author>
            <author initials="P" surname="Mendes" fullname="Paulo Mendes"></author>
            <date month="January" year="2018" />
        </front>
        <seriesInfo name="Technical Report COPE-SITI-TR-18-01" value="" />
</reference>
</references>

<references title="Informative References">
<reference anchor="NDN-opportunisticnets" target="">
        <front>
            <title>Named-Data Networking in Opportunistic Networks</title>
            <author initials="S" surname="Dynerowicz" fullname="Seweryn Dynerowicz"></author>
            <author initials="P" surname="Mendes" fullname="Paulo Mendes"></author>
            <date month="September" year="2017" />
        </front>
        <seriesInfo name="ACM ICN, Berlin, Germany" value="" />
</reference>
<reference anchor="Umobile" target="">
        <front>
            <title>Connecting the Edges: A Universal, Mobile centric and Opportunistic Communications Architecture</title>
            <author>
               <organization>C. Sarros, et al</organization>
            </author>
            <date month="February" year="2018" />
        </front>
        <seriesInfo name="IEEE Communication Magazine" value="" />
</reference>
<reference anchor="UmobileD45" target="">
        <front>
            <title>UMOBILE D45 - Report on Data Collection and Inference Models</title>
            <author>
               <organization>R. Sofia, et al</organization>
            </author>
            <date month="September" year="2018" />
        </front>
        <seriesInfo name="Umobile Technical Report" value="" />
</reference>
<reference anchor="ChronoSync" target="">
        <front>
            <title>Lets ChronoSync:Decentralized Dataset State Synchronization in Named Data Networking</title>
            <author initials="Z" surname="Zhu" fullname="Zhenkai Zhu"></author>
            <author initials="A" surname="Afanasyev" fullname="Alexander Afanasyev"></author>
            <date month="October" year="2013" />
        </front>
        <seriesInfo name="in Proc. IEEE ICNP" value="" />
</reference>
<reference anchor="PartialSync" target="">
        <front>
            <title>PartialSync:Efficient Synchronization of a Partial Namespace in NDN</title>
            <author initials="M" surname="Zhang" fullname="Minsheng Zhang"></author>
            <author initials="V" surname="Lehman" fullname="Vince Lehman"></author>
            <author initials="L" surname="Wang" fullname="Lan Wang"></author>
            <date month="June" year="2016" />
        </front>
        <seriesInfo name="NDN Technical Report NDN-0039" value="" />
</reference>
<reference anchor="Loop-free" target="">
        <front>
            <title>How to Establish Loop-Free Multipath Routes in Named Data Networking</title>
            <author initials="K" surname="Schneider" fullname="Klaus Schneider"></author>
            <author initials="B" surname="Zhang" fullname="Beichuan Zhang"></author>
            <date month="April" year="2017" />
        </front>
        <seriesInfo name="NDN Technical Report NDN-0044" value="" />
</reference>
<reference anchor="Scorp" target="">
        <front>
            <title>Social-aware Opportunistic Routing Protocol based on User's Interactions and Interests</title>
            <author initials="W" surname="Moreira" fullname="Waldir Moreira"></author>
            <author initials="P" surname="Mendes" fullname="Paulo Mendes"></author>
            <author initials="S" surname="Sargento" fullname="Susana Sargento"></author>
            <date month="October" year="2013" />
        </front>
        <seriesInfo name=" in Proc. of AdhocNets, Barcelona, Spain" value="" />
</reference>
<reference anchor="Dlife" target="">
        <front>
            <title>Opportunistic Routing based on daily routines</title>
            <author initials="W" surname="Moreira" fullname="Waldir Moreira"></author>
            <author initials="P" surname="Mendes" fullname="Paulo Mendes"></author>
            <author initials="S" surname="Sargento" fullname="Susana Sargento"></author>
            <date month="June" year="2012" />
        </front>
        <seriesInfo name="in Proc. of IEEE WoWMoM workshop on autonomic and opportunistic communications, San Francisco, USA" value="" />
</reference>
<reference anchor="Self-learning" target="">
        <front>
            <title>On Broadcast-based Self-Learning in Named Data Networking</title>
            <author initials="J" surname="Shi" fullname="Junxiao Shi"></author>
            <author initials="E" surname="Newberry" fullname="Eric Newberry"></author>
            <author initials="B" surname="Zhang" fullname="Beichuan Zhang"></author>
            <date month="June" year="2017" />
        </front>
        <seriesInfo name="in Proc. Of IFIP Networking, Stockholm" value="" />
</reference>
<reference anchor="Dlife-draft" target="">
        <front>
            <title>Opportunistic Routing based on Users Daily Life Routine</title>
            <author initials="W" surname="Moreira" fullname="Waldir Moreira"></author>
            <author initials="P" surname="Mendes" fullname="Paulo Mendes"></author>
            <author initials="E" surname="Cerqueira" fullname="Eduardo Cerqueira"></author>
            <date month="May" year="2014" />
        </front>
        <seriesInfo name="IETF Internet Draft (draft-moreira-dlife-04)" value="" />
</reference>
<reference anchor="ICN-routing-opp" target="">
        <front>
            <title>Information-centric Routing for Opportunistic Wireless Networks</title>
            <author>
               <organization>P. Mendes, et al</organization>
            </author>
            <date month="September" year="2018" />
        </front>
        <seriesInfo name="n ACM ICN, Boston, USA" value="" />
</reference>
<reference anchor="NDN-emergency" target="">
        <front>
            <title>Named-data Emergency Network Services</title>
            <author initials="M" surname="Tavares" fullname="Miguel Tavares"></author>
            <author initials="O" surname="Aponte" fullname="Omar Aponte"></author>
            <author initials="P" surname="Mendes" fullname="Paulo Mendes"></author>
            <date month="June" year="2018" />
        </front>
        <seriesInfo name="in ACM MOBISYS, Munich, Germany" value="" />
</reference>
<reference anchor="Optimal-stopping" target="">
        <front>
            <title>Efficient broadcast in opportunistic networks using optimal stopping theory</title>
            <author initials="C" surname="Borrego" fullname="Carlos Borrego"></author>
            <author initials="J" surname="Borrell" fullname="Joan Borrell"></author>
            <author initials="S" surname="Robles" fullname="Sergi Robles"></author>
            <date month="May" year="2019" />
        </front>
        <seriesInfo name="Ad Hoc Networks" value="" />
</reference>
<reference anchor="NAC" target="">
        <front>
            <title>NAC: Automating Access Control via Named Data</title>
            <author>
               <organization>Z. Zhang, et al</organization>
            </author>
            <date month="October" year="2018" />
        </front>
        <seriesInfo name="in IEEE MILCOM" value="" />
</reference>
<reference anchor="Privacy" target="">
        <front>
            <title>Privacy-Preserving Forwarding using Homomorphic Encryption for Information-Centric Wireless Ad Hoc Networks</title>
            <author>
               <organization>C. Borrego, et al</organization>
            </author>
            <date month="July" year="2019" />
        </front>
        <seriesInfo name="IEEE Communications Letters" value="" />
</reference>
<reference anchor="PrivHab" target="">
        <front>
            <title>PrivHab+: A secure geographic routing protocol for DTN</title>
            <author>
               <organization>S.Carmona, et al</organization>
            </author>
            <date month="May" year="2016" />
        </front>
        <seriesInfo name="Elsevier Computer Communications" value="" />
</reference>
<?rfc include="reference.RFC.3986.xml"?>
<?rfc include="reference.RFC.4838.xml"?>
<?rfc include="reference.RFC.5050.xml"?>
<?rfc include="reference.RFC.6693.xml"?>
<?rfc include="reference.RFC.7476.xml"?>
</references>

</back>
</rfc>
